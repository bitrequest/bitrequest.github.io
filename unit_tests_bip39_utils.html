<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>BIP39 Utils - Interactive Test Suite</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            line-height: 1.6;
        }
        h1 { color: #00d4ff; margin-bottom: 5px; }
        h2 { color: #00d4ff; border-bottom: 1px solid #333; padding-bottom: 10px; margin-top: 30px; }
        h3 { color: #888; margin: 0 0 20px 0; font-weight: normal; }
        .test-section {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        .test-section h4 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 16px;
        }
        .test-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        input, textarea, select {
            background: #0f0f23;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        input { flex: 1; min-width: 200px; }
        textarea { width: 100%; min-height: 80px; resize: vertical; }
        button {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            white-space: nowrap;
        }
        button:hover { background: #00a8cc; }
        button.secondary {
            background: #4a5568;
            color: #fff;
        }
        button.secondary:hover { background: #5a6578; }
        .output {
            background: #0f0f23;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 13px;
            word-break: break-all;
            white-space: pre-wrap;
        }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .info { color: #00d4ff; }
        .warn { color: #ffaa00; }
        #test-results {
            background: #0f0f23;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
        }
        .test-pass { color: #00ff88; }
        .test-fail { color: #ff4444; }
        .test-count {
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        a { color: #00d4ff; }
        .note {
            background: #1e3a5f;
            border-left: 3px solid #00d4ff;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 13px;
        }
        .warning {
            background: #3f2e1e;
            border-left: 3px solid #ffaa00;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 13px;
        }
        .phrase-display {
            background: #0f0f23;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 15px;
            font-size: 16px;
            letter-spacing: 1px;
            text-align: center;
            margin: 10px 0;
        }
        .word-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 10px 0;
        }
        .word-item {
            background: #16213e;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
        }
        .word-num {
            color: #666;
            font-size: 10px;
        }
        .derivation-path {
            font-family: monospace;
            background: #0f0f23;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h1>üîë BIP39 Utils</h1>
    <h3>Standalone BIP39/BIP32 HD Wallet Library v<span id="version"></span></h3>
    
    <div class="note">
        <strong>Dependencies:</strong> 
        <a href="https://github.com/bitrequest/bitrequest.github.io/blob/master/assets_js_lib_sjcl.js">sjcl.js</a> ‚Üí 
        <a href="https://github.com/bitrequest/bitrequest.github.io/blob/master/assets_js_lib_crypto_utils.js">crypto_utils.js</a> ‚Üí 
        <a href="https://github.com/bitrequest/bitrequest.github.io/blob/master/assets_js_lib_bip39_utils.js">bip39_utils.js</a><br>
        <strong>Test phrase:</strong> <a href="https://github.com/bitcoinbook/bitcoinbook/blob/f8b883dcd4e3d1b9adf40fed59b7e898fbd9241f/ch05.asciidoc">army van defense carry jealous true garbage claim echo media make crunch</a><br>
        <strong>Repository:</strong> <a href="https://github.com/bitrequest/bip39-utils-js">github.com/bitrequest/bip39-utils-js</a>
    </div>

    <div class="warning">
        ‚ö†Ô∏è <strong>Security Warning:</strong> Never enter real seed phrases on websites. This tool is for testing and educational purposes only.
    </div>

    <!-- Automated Tests -->
    <h2>üß™ Automated Unit Tests</h2>
    <button onclick="runAllTests()">Run All Tests</button>
    <div id="test-results"></div>

    <!-- Interactive Tools -->
    <h2>üõ†Ô∏è Interactive Tools</h2>

    <!-- Generate Mnemonic -->
    <div class="test-section">
        <h4>Generate New Mnemonic Phrase</h4>
        <div class="test-row">
            <select id="word-count">
                <option value="12" selected>12 words (128-bit)</option>
                <option value="15">15 words (160-bit)</option>
                <option value="18">18 words (192-bit)</option>
                <option value="21">21 words (224-bit)</option>
                <option value="24">24 words (256-bit)</option>
            </select>
            <button onclick="generateMnemonic()">Generate Mnemonic</button>
        </div>
        <div class="output" id="generate-output"></div>
    </div>

    <!-- Validate Mnemonic -->
    <div class="test-section">
        <h4>Validate Mnemonic Phrase</h4>
        <div class="test-row">
            <textarea id="validate-input" placeholder="Enter 12/15/18/21/24 word mnemonic phrase"></textarea>
        </div>
        <div class="test-row">
            <button onclick="validateMnemonic()">Validate</button>
            <button class="secondary" onclick="useTestPhrase()">Use Test Phrase</button>
        </div>
        <div class="output" id="validate-output"></div>
    </div>

    <!-- Mnemonic to Seed -->
    <div class="test-section">
        <h4>Mnemonic ‚Üí Seed (PBKDF2)</h4>
        <div class="test-row">
            <textarea id="seed-mnemonic" placeholder="Enter mnemonic phrase"></textarea>
        </div>
        <div class="test-row">
            <input type="text" id="seed-passphrase" placeholder="Optional BIP39 passphrase">
        </div>
        <div class="test-row">
            <button onclick="mnemonicToSeed()">Generate Seed</button>
            <button class="secondary" onclick="useTestPhraseForSeed()">Use Test Phrase</button>
        </div>
        <div class="output" id="seed-output"></div>
    </div>

    <!-- Seed to Root Key -->
    <div class="test-section">
        <h4>Seed ‚Üí Master Root Key (HMAC-SHA512)</h4>
        <div class="test-row">
            <textarea id="rootkey-seed" placeholder="Enter 128-character hex seed"></textarea>
        </div>
        <div class="test-row">
            <button onclick="seedToRootKey()">Get Root Key</button>
            <button class="secondary" onclick="useTestSeed()">Use Test Seed</button>
        </div>
        <div class="output" id="rootkey-output"></div>
    </div>

    <!-- BIP32 Derivation -->
    <div class="test-section">
        <h4>BIP32 Key Derivation</h4>
        <div class="test-row">
            <input type="text" id="derive-key" placeholder="64-char hex private key (master key)">
        </div>
        <div class="test-row">
            <input type="text" id="derive-chaincode" placeholder="64-char hex chain code">
        </div>
        <div class="test-row">
            <input type="text" id="derive-path-base" value="m/84'/0'/0'/0/" readonly style="width: 200px; background: #1a1a2e; color: #888;">
            <input type="number" id="derive-path-index" value="0" min="0" max="999" style="width: 70px;" onchange="deriveKeyIfReady()">
            <select id="derive-coin" onchange="updateDerivePath()">
                <option value="bitcoin-segwit" data-path="m/84'/0'/0'/0/">Bitcoin SegWit</option>
                <option value="bitcoin" data-path="m/44'/0'/0'/0/">Bitcoin Legacy</option>
                <option value="litecoin-segwit" data-path="m/84'/2'/0'/0/">Litecoin SegWit</option>
                <option value="litecoin" data-path="m/44'/2'/0'/0/">Litecoin Legacy</option>
                <option value="dogecoin" data-path="m/44'/3'/0'/0/">Dogecoin</option>
                <option value="dash" data-path="m/44'/5'/0'/0/">Dash</option>
                <option value="ethereum" data-path="m/44'/60'/0'/0/">Ethereum</option>
                <option value="bitcoin-cash" data-path="m/44'/145'/0'/0/">Bitcoin Cash</option>
                <option value="kaspa" data-path="m/44'/111111'/0'/0/">Kaspa</option>
            </select>
        </div>
        <div class="test-row">
            <button onclick="deriveKey()">Derive Key</button>
            <button class="secondary" onclick="useTestRootKey()">Use Test Root Key</button>
        </div>
        <div class="output" id="derive-output"></div>
    </div>

    <!-- Batch Derivation -->
    <div class="test-section">
        <h4>Batch Address Derivation</h4>
        <div class="test-row">
            <textarea id="batch-mnemonic" placeholder="Enter mnemonic phrase"></textarea>
        </div>
        <div class="test-row">
            <select id="batch-coin">
                <option value="bitcoin-segwit">Bitcoin SegWit</option>
                <option value="bitcoin">Bitcoin Legacy</option>
                <option value="litecoin-segwit">Litecoin SegWit</option>
                <option value="litecoin">Litecoin Legacy</option>
                <option value="dogecoin">Dogecoin</option>
                <option value="dash">Dash</option>
                <option value="ethereum">Ethereum</option>
                <option value="bitcoin-cash">Bitcoin Cash</option>
                <option value="kaspa">Kaspa</option>
            </select>
            <input type="number" id="batch-count" value="5" min="1" max="20" style="width: 80px;">
            <button onclick="batchDerive()">Derive Addresses</button>
        </div>
        <div class="test-row">
            <button class="secondary" onclick="useTestPhraseForBatch()">Use Test Phrase</button>
        </div>
        <div class="output" id="batch-output"></div>
    </div>

    <!-- Generate xPubs -->
    <div class="test-section">
        <h4>Generate Extended Public Keys (xpub/zpub)</h4>
        <div class="test-row">
            <textarea id="xpub-gen-mnemonic" placeholder="Enter mnemonic phrase"></textarea>
        </div>
        <div class="test-row">
            <button onclick="generateAllXpubs()">Generate xPubs</button>
            <button class="secondary" onclick="useTestPhraseForXpubs()">Use Test Phrase</button>
        </div>
        <div class="output" id="xpub-gen-output"></div>
    </div>

    <!-- xPub Parsing -->
    <div class="test-section">
        <h4>Parse Extended Public Key (xpub/zpub)</h4>
        <div class="test-row">
            <textarea id="xpub-input" placeholder="Enter xpub, ypub, or zpub"></textarea>
        </div>
        <div class="test-row">
            <button onclick="parseXpub()">Parse xPub</button>
            <label style="margin-left: 10px; color: #888;">Index:</label>
            <input type="number" id="xpub-index" value="0" min="0" max="999" style="width: 80px;">
        </div>
        <div class="output" id="xpub-output"></div>
    </div>

    <!-- Scripts -->
    <script src="assets_js_lib_sjcl.js"></script>
    <script src="assets_js_lib_crypto_utils.js"></script>
    <script src="assets_js_lib_bip39_utils.js"></script>
    <script>
        // Display version
        document.getElementById("version").textContent = Bip39Utils.version || "1.1.0";

        // Shorthand reference to test constants from library
        const TestVector = Bip39Utils.bip39_utils_test_vectors;

        // Kaspa BIP32 configuration (for interactive tools)
        const KASPA_CONFIG = {
            "root_path": "m/44'/111111'/0'/0/",
            "prefix": {
                "pub": 0,
                "pubx": 59716398,   // 0x038f332e ‚Üí kpub
                "privx": 59715316  // 0x038f2ef4 ‚Üí kprv
            },
            "pk_vbytes": {
                "wif": 128
            }
        };

        // Test framework
        const tests = [];
        let passed = 0, failed = 0;

        function test(name, fn) {
            tests.push({ name, fn });
        }

        function assertEqual(actual, expected, msg) {
            if (actual !== expected) {
                throw new Error(msg + " Expected: " + expected + " Got: " + actual);
            }
        }

        function assertTrue(condition, msg) {
            if (!condition) {
                throw new Error(msg);
            }
        }

        // Helper to log errors to console with full details
        function logError(context, e) {
            console.group("‚ùå " + context + " Error");
            console.error("Message:", e.message || e);
            console.error("Full error:", e);
            if (e.stack) console.error("Stack:", e.stack);
            console.groupEnd();
        }

        // ============================================================
        // BUILT-IN LIBRARY TESTS
        // ============================================================

        test("Bip39Utils.test_seed: verify mnemonic ‚Üí seed derivation", () => {
            assertTrue(Bip39Utils.test_seed() === true, "seed derivation should work");
        });

        test("Bip39Utils.test_derivation: verify BIP44 address derivation", () => {
            assertTrue(Bip39Utils.test_derivation() === true, "address derivation should work");
        });

        test("Bip39Utils.test_xpub_support: verify xpub derivation", () => {
            assertTrue(Bip39Utils.test_xpub_support() === true, "xpub derivation should work");
        });

        test("Bip39Utils.test_bip39_compatibility: full compatibility check", () => {
            const results = Bip39Utils.test_bip39_compatibility();
            assertTrue(results.compatible === true, "BIP39 should be compatible");
            assertTrue(results.crypto_api === true, "crypto API should be available");
            assertTrue(results.bigint === true, "BigInt should be functional");
            assertTrue(results.secp256k1 === true, "secp256k1 should work");
            assertTrue(results.seed === true, "seed derivation should work");
            assertTrue(results.derivation === true, "address derivation should work");
            assertTrue(results.xpub === true, "xpub derivation should work");
        });

        // ============================================================
        // TEST CONSTANTS VALIDATION
        // ============================================================

        test("bip39_utils_const: test_phrase produces expected_seed", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            assertEqual(seed, TestVector.expected_seed, "Should produce expected seed");
        });

        test("bip39_utils_const: expected_seed produces expected_address", () => {
            const root_key = Bip39Utils.get_rootkey(TestVector.expected_seed);
            const derive_params = {
                "dpath": "m/44'/0'/0'/0/0",
                "key": root_key.slice(0, 64),
                "cc": root_key.slice(64)
            };
            const derived_keys = Bip39Utils.derive_x(derive_params);
            const bip32_config = Bip39Utils.get_bip32_config("bitcoin");
            const derived_address = Bip39Utils.format_keys(TestVector.expected_seed, derived_keys, bip32_config, 0, "bitcoin");
            assertEqual(derived_address.address, TestVector.expected_address, "Should produce expected address");
        });

        test("bip39_utils_const: test_xpub produces expected_address", () => {
            const xpub_data = Bip39Utils.key_cc_xpub(TestVector.test_xpub);
            const derive_params = {
                "dpath": "M/0/0",
                "key": xpub_data.key,
                "cc": xpub_data.cc,
                "vb": xpub_data.version
            };
            const derived_keys = Bip39Utils.derive_x(derive_params);
            const bip32_config = Bip39Utils.get_bip32_config("bitcoin");
            const derived_address = Bip39Utils.format_keys(null, derived_keys, bip32_config, 0, "bitcoin");
            assertEqual(derived_address.address, TestVector.expected_address, "Xpub should produce expected address");
        });

        // ============================================================
        // UNIT TESTS
        // ============================================================

        // === Mnemonic Validation Tests ===

        test("validate_mnemonic: valid test phrase", () => {
            const result = Bip39Utils.validate_mnemonic(TestVector.test_phrase);
            assertEqual(result, true, "Test phrase should be valid");
        });

        test("validate_mnemonic: invalid phrase (wrong word)", () => {
            const invalid = "army van defense carry jealous true garbage claim echo media make xyz";
            const result = Bip39Utils.validate_mnemonic(invalid);
            assertEqual(result, false, "Invalid word should fail");
        });

        test("validate_mnemonic: invalid checksum", () => {
            // Use a phrase with wrong checksum word (abandon x11 + abandon = invalid checksum)
            const badChecksum = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
            const result = Bip39Utils.validate_mnemonic(badChecksum);
            assertEqual(result, false, "Bad checksum should fail");
        });

        test("validate_mnemonic: valid all-abandon phrase", () => {
            // "abandon" x 11 + "about" is actually a valid BIP39 phrase (correct checksum)
            const allAbandon = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
            const result = Bip39Utils.validate_mnemonic(allAbandon);
            assertEqual(result, true, "This phrase has correct checksum");
        });

        test("validate_mnemonic: 24 word phrase", () => {
            const phrase24 = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art";
            const result = Bip39Utils.validate_mnemonic(phrase24);
            assertTrue(typeof result === "boolean", "Should handle 24 words");
        });

        test("validate_mnemonic: word 'true' works correctly", () => {
            // Test that the word "true" (which is in BIP39 wordlist) validates correctly
            const result = Bip39Utils.validate_mnemonic(TestVector.test_phrase);
            assertEqual(result, true, "Phrase with word 'true' should validate");
        });

        // === Mnemonic to Seed Tests ===

        test("mnemonic_to_seed: test phrase", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            assertEqual(seed, TestVector.expected_seed, "Seed should match expected");
        });

        test("mnemonic_to_seed: output length (128 hex chars)", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            assertEqual(seed.length, 128, "Seed should be 64 bytes = 128 hex");
        });

        test("mnemonic_to_seed: deterministic", () => {
            const seed1 = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const seed2 = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            assertEqual(seed1, seed2, "Same phrase should give same seed");
        });

        test("mnemonic_to_seed: with passphrase", () => {
            const seedNoPass = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const seedWithPass = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase, "password");
            assertTrue(seedNoPass !== seedWithPass, "Passphrase should change seed");
        });

        // === Root Key Tests ===

        test("get_rootkey: output length (128 hex chars)", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const rootkey = Bip39Utils.get_rootkey(seed);
            assertEqual(rootkey.length, 128, "Root key should be 128 hex chars");
        });

        test("get_rootkey: deterministic", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root1 = Bip39Utils.get_rootkey(seed);
            const root2 = Bip39Utils.get_rootkey(seed);
            assertEqual(root1, root2, "Should be deterministic");
        });

        test("get_rootkey: different seeds give different roots", () => {
            const seed1 = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const seed2 = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase, "password");
            const root1 = Bip39Utils.get_rootkey(seed1);
            const root2 = Bip39Utils.get_rootkey(seed2);
            assertTrue(root1 !== root2, "Different seeds give different roots");
        });

        // === Key Derivation Tests ===

        test("derive_x: BIP44 path", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            assertTrue(derived.hasOwnProperty("key"), "Should have key");
            assertEqual(derived.key.length, 64, "Key should be 32 bytes");
        });

        test("derive_x: BIP84 path", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            assertTrue(derived.hasOwnProperty("key"), "Should have key");
            assertEqual(derived.purpose, "84'", "Should track purpose");
        });

        test("derive_x: different indices give different keys", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const key0 = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const key1 = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'/0/1",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            assertTrue(key0.key !== key1.key, "Different indices give different keys");
        });

        test("derive_child_key: single derivation step", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const child = Bip39Utils.derive_child_key(
                root.slice(0, 64),
                root.slice(64),
                "80000000", // hardened 0
                false,
                true
            );
            assertTrue(child.hasOwnProperty("key"), "Should have key");
            assertTrue(child.hasOwnProperty("chaincode"), "Should have chain code");
        });

        // === Address Generation Tests ===

        test("format_keys: Bitcoin legacy address", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("bitcoin"), 0, "bitcoin");
            assertTrue(formatted.address.startsWith("1"), "Legacy address starts with 1");
        });

        test("format_keys: Bitcoin SegWit address (BIP84)", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("bitcoin"), 0, "bitcoin");
            assertTrue(formatted.address.startsWith("bc1q"), "SegWit address starts with bc1q");
        });

        test("format_keys: Ethereum address", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/60'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("ethereum"), 0, "ethereum");
            assertTrue(formatted.address.startsWith("0x"), "Ethereum address starts with 0x");
            assertEqual(formatted.address.length, 42, "Ethereum address is 42 chars");
        });

        test("format_keys: Litecoin SegWit address", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/2'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("litecoin"), 0, "litecoin");
            assertTrue(formatted.address.startsWith("ltc1q"), "Litecoin SegWit starts with ltc1q");
        });

        test("format_keys: Dogecoin address", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/3'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("dogecoin"), 0, "dogecoin");
            assertTrue(formatted.address.startsWith("D"), "Dogecoin address starts with D");
        });

        // === Kaspa Address Derivation Tests ===

        test("Kaspa address derivation: valid kaspa: address format", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/111111'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const pubkey = CryptoUtils.get_publickey(derived.key);
            const address = CryptoUtils.pub_to_kaspa_address(pubkey);
            assertTrue(address.startsWith("kaspa:q"), "Kaspa address starts with kaspa:q");
            assertEqual(address.length, 67, "Kaspa address is 67 chars (kaspa: + 61 bech32)");
        });

        test("Kaspa address derivation: multiple indices produce different addresses", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived0 = Bip39Utils.derive_x({
                dpath: "m/44'/111111'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const derived1 = Bip39Utils.derive_x({
                dpath: "m/44'/111111'/0'/0/1",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const addr0 = CryptoUtils.pub_to_kaspa_address(CryptoUtils.get_publickey(derived0.key));
            const addr1 = CryptoUtils.pub_to_kaspa_address(CryptoUtils.get_publickey(derived1.key));
            assertTrue(addr0 !== addr1, "Different indices produce different addresses");
        });

        test("Kaspa kpub generation: produces valid kpub", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/111111'/0'",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const ext_keys_result = Bip39Utils.ext_keys(derived, KASPA_CONFIG);
            assertTrue(ext_keys_result.xpub.startsWith("kpub"), "Kaspa xpub starts with kpub");
        });

        test("Kaspa kpub parsing: can parse kpub and derive addresses", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/111111'/0'",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const ext_keys_result = Bip39Utils.ext_keys(derived, KASPA_CONFIG);
            const kpub = ext_keys_result.xpub;
            
            // Parse kpub and derive address
            const parsed = Bip39Utils.key_cc_xpub(kpub);
            const child_derived = Bip39Utils.derive_x({
                dpath: "M/0/0",
                key: parsed.key,
                cc: parsed.cc
            });
            const address = CryptoUtils.pub_to_kaspa_address(child_derived.key);
            assertTrue(address.startsWith("kaspa:q"), "Derived address from kpub is valid");
        });

        test("format_keys: expected Bitcoin address from test phrase", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/44'/0'/0'/0/0",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const formatted = Bip39Utils.format_keys(seed, derived, Bip39Utils.get_bip32_config("bitcoin"), 0, "bitcoin");
            assertEqual(formatted.address, TestVector.expected_address, "Should match expected address");
        });

        // === xPub Tests ===

        test("key_cc_xpub: parse xpub structure", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const extended = Bip39Utils.ext_keys(derived, Bip39Utils.get_bip32_config("bitcoin"));
            // ext_keys returns ext_pub for the public extended key
            const parsed = Bip39Utils.key_cc_xpub(extended.ext_pub);
            assertTrue(parsed.hasOwnProperty("key"), "Should have key");
            assertTrue(parsed.hasOwnProperty("cc"), "Should have chain code");
        });

        test("ext_keys: generate extended keys", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const config = Bip39Utils.get_bip32_config("bitcoin");
            const extended = Bip39Utils.ext_keys(derived, config);
            // ext_keys returns object with ext_key (always) and ext_pub (when xpub is false)
            assertTrue(typeof extended === "object", "Should return object");
            assertTrue(Object.keys(extended).length > 0, "Should have at least one key");
        });

        test("xpub_obj: create xpub object", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            // xpub_obj signature: (coin, root_path, chain_code, key)
            const xpubObj = Bip39Utils.xpub_obj("bitcoin", "m/84'/0'/0'/0", root.slice(64), root.slice(0, 64));
            assertTrue(typeof xpubObj === "object", "Should return object");
            assertTrue(xpubObj.hasOwnProperty("xpub"), "Should have xpub property");
        });

        // === Mnemonic Generation Tests ===

        test("generate_mnemonic: 12 words", () => {
            const mnemonic = Bip39Utils.generate_mnemonic(12);
            const words = mnemonic.split(" ");
            assertEqual(words.length, 12, "Should be 12 words");
        });

        test("generate_mnemonic: valid checksum", () => {
            const mnemonic = Bip39Utils.generate_mnemonic(12);
            const isValid = Bip39Utils.validate_mnemonic(mnemonic);
            assertEqual(isValid, true, "Generated mnemonic should be valid");
        });

        test("generate_mnemonic: 24 words valid", () => {
            const mnemonic = Bip39Utils.generate_mnemonic(24);
            const words = mnemonic.split(" ");
            assertEqual(words.length, 24, "Should be 24 words");
            const isValid = Bip39Utils.validate_mnemonic(mnemonic);
            assertEqual(isValid, true, "Should be valid");
        });

        test("generate_mnemonic: random each time", () => {
            const m1 = Bip39Utils.generate_mnemonic(12);
            const m2 = Bip39Utils.generate_mnemonic(12);
            assertTrue(m1 !== m2, "Should be random");
        });

        // === find_invalid_word Tests ===

        test("find_invalid_word: valid phrase returns undefined", () => {
            // find_invalid_word expects an array of words
            const words = TestVector.test_phrase.split(" ");
            const result = Bip39Utils.find_invalid_word(words);
            assertEqual(result, undefined, "Valid phrase should return undefined");
        });

        test("find_invalid_word: detects invalid word", () => {
            const invalid = "army van defense carry jealous true garbage claim echo media make xyz123".split(" ");
            const result = Bip39Utils.find_invalid_word(invalid);
            assertEqual(result, "xyz123", "Should return the invalid word");
        });

        // === BIP32 Configuration Tests ===

        test("get_bip32_config: Bitcoin config", () => {
            const config = Bip39Utils.get_bip32_config("bitcoin");
            assertTrue(config.hasOwnProperty("root_path"), "Should have root_path");
            assertTrue(config.hasOwnProperty("prefix"), "Should have prefix");
        });

        test("get_bip32_config: Ethereum config", () => {
            const config = Bip39Utils.get_bip32_config("ethereum");
            assertTrue(config !== false, "Should return config for Ethereum");
        });

        test("get_bip32_config: unknown coin returns false", () => {
            const config = Bip39Utils.get_bip32_config("unknowncoin");
            assertEqual(config, false, "Unknown coin should return false");
        });

        test("bip32_configs: has expected coins", () => {
            const configs = Bip39Utils.bip32_configs;
            assertTrue(configs.hasOwnProperty("bitcoin"), "Has bitcoin");
            assertTrue(configs.hasOwnProperty("litecoin"), "Has litecoin");
            assertTrue(configs.hasOwnProperty("ethereum"), "Has ethereum");
        });

        // === Utility Tests ===

        test("shuffle_array: returns same length", () => {
            const original = [1, 2, 3, 4, 5];
            const shuffled = Bip39Utils.shuffle_array([...original]);
            assertEqual(shuffled.length, original.length, "Same length");
        });

        test("shuffle_array: contains same elements", () => {
            const original = [1, 2, 3, 4, 5];
            const shuffled = Bip39Utils.shuffle_array([...original]);
            const sortedOriginal = [...original].sort();
            const sortedShuffled = [...shuffled].sort();
            assertEqual(JSON.stringify(sortedOriginal), JSON.stringify(sortedShuffled), "Same elements");
        });

        test("parse_seed: prepares mnemonic and passphrase for PBKDF2", () => {
            // parse_seed takes mnemonic and optional passphrase, returns bit arrays for PBKDF2
            const parsed = Bip39Utils.parse_seed(TestVector.test_phrase, "");
            assertTrue(parsed.hasOwnProperty("mnemonic"), "Should have mnemonic bits");
            assertTrue(parsed.hasOwnProperty("passphrase"), "Should have passphrase bits (salted)");
        });

        test("objectify_extended: parse extended key", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const derived = Bip39Utils.derive_x({
                dpath: "m/84'/0'/0'",
                key: root.slice(0, 64),
                cc: root.slice(64)
            });
            const extended = Bip39Utils.ext_keys(derived, Bip39Utils.get_bip32_config("bitcoin"));
            // objectify_extended takes a Base58Check decoded hex string, not an encoded xpub
            const decoded = CryptoUtils.b58check_decode(extended.ext_key);
            const obj = Bip39Utils.objectify_extended(decoded);
            assertTrue(typeof obj === "object", "Should return object");
        });

        // === keypair_array Tests ===

        test("keypair_array: derive multiple addresses", () => {
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            const root = Bip39Utils.get_rootkey(seed);
            const config = Bip39Utils.get_bip32_config("bitcoin");
            const pairs = Bip39Utils.keypair_array(
                seed,
                new Array(5),
                0,
                "m/84'/0'/0'/0/",
                config,
                root.slice(0, 64),
                root.slice(64),
                "bitcoin",
                null
            );
            assertEqual(pairs.length, 5, "Should return 5 addresses");
            assertTrue(pairs[0].address.startsWith("bc1q"), "First address is SegWit");
        });

        // === Test Constants ===

        test("test_phrase: is defined", () => {
            assertTrue(typeof TestVector.test_phrase === "string", "test_phrase should be string");
            assertTrue(TestVector.test_phrase.length > 0, "test_phrase should not be empty");
        });

        test("expected_seed: is defined", () => {
            assertTrue(typeof TestVector.expected_seed === "string", "expected_seed should be string");
            assertEqual(TestVector.expected_seed.length, 128, "expected_seed should be 128 chars");
        });

        test("expected_address: is defined", () => {
            assertTrue(typeof TestVector.expected_address === "string", "expected_address should be string");
            assertTrue(TestVector.expected_address.startsWith("1"), "expected_address should start with 1");
        });

        // === Integration Test ===

        test("full derivation flow: phrase ‚Üí seed ‚Üí address", () => {
            // This test verifies the complete derivation chain
            const seed = Bip39Utils.mnemonic_to_seed(TestVector.test_phrase);
            assertEqual(seed, TestVector.expected_seed, "Seed should match");
            
            const root_key = Bip39Utils.get_rootkey(seed);
            const derive_params = {
                "dpath": "m/44'/0'/0'/0/0",
                "key": root_key.slice(0, 64),
                "cc": root_key.slice(64)
            };
            const derived_keys = Bip39Utils.derive_x(derive_params);
            const bip32_config = Bip39Utils.get_bip32_config("bitcoin");
            const result = Bip39Utils.format_keys(seed, derived_keys, bip32_config, 0, "bitcoin");
            assertEqual(result.address, TestVector.expected_address, "Address should match expected");
        });

        // Run all tests
        function runAllTests() {
            const resultsDiv = document.getElementById("test-results");
            resultsDiv.innerHTML = "<span class='info'>Running tests...</span>";
            passed = 0;
            failed = 0;

            console.group("üß™ Bip39Utils Unit Tests");
            console.log("Running " + tests.length + " tests...");

            setTimeout(() => {
                let output = "";
                
                for (const t of tests) {
                    try {
                        t.fn();
                        output += "<span class='test-pass'>‚úì " + t.name + "</span><br>\n";
                        passed++;
                    } catch (e) {
                        output += "<span class='test-fail'>‚úó " + t.name + "<br>  " + e.message + "</span><br>\n";
                        failed++;
                        logError("TEST: " + t.name, e);
                    }
                }

                console.log("‚úÖ Passed: " + passed + " | ‚ùå Failed: " + failed);
                console.groupEnd();

                const summary = "<div class='test-count'>Tests: <span class='test-pass'>" + passed + " passed</span>, <span class='" + (failed ? "test-fail" : "") + "'>" + failed + " failed</span> of " + tests.length + " total</div>";
                resultsDiv.innerHTML = summary + output;
            }, 10);
        }

        // ============================================================
        // INTERACTIVE TOOLS
        // ============================================================

        function generateMnemonic() {
            const output = document.getElementById("generate-output");
            try {
                const word_count = parseInt(document.getElementById("word-count").value),
                      mnemonic = Bip39Utils.generate_mnemonic(word_count),
                      words = mnemonic.split(" ");
                
                let word_grid = "<div class='word-grid'>";
                words.forEach((word, i) => {
                    word_grid += "<div class='word-item'><span class='word-num'>" + (i + 1) + "</span><br>" + word + "</div>";
                });
                word_grid += "</div>";
                
                const is_valid = Bip39Utils.validate_mnemonic(mnemonic);
                
                output.innerHTML = 
                    "<span class='info'>Generated " + word_count + "-word mnemonic:</span>\n\n" +
                    "<div class='phrase-display'>" + mnemonic + "</div>\n" +
                    word_grid +
                    "\n<span class='" + (is_valid ? "success" : "error") + "'>Checksum: " + (is_valid ? "‚úì Valid" : "‚úó Invalid") + "</span>";
            } catch (e) {
                logError("generateMnemonic", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function validateMnemonic() {
            const output = document.getElementById("validate-output"),
                  input = document.getElementById("validate-input").value.trim();
            
            if (!input) {
                output.innerHTML = "<span class='warn'>Please enter a mnemonic phrase</span>";
                return;
            }
            
            try {
                const words = input.split(/\s+/),
                      word_count = words.length,
                      is_valid = Bip39Utils.validate_mnemonic(input),
                      invalid_word = Bip39Utils.find_invalid_word(words);
                
                let result = "<span class='info'>Word count:</span> " + word_count + "\n";
                
                if (invalid_word) {
                    result += "<span class='error'>Invalid word found: \"" + invalid_word + "\"</span>\n";
                }
                
                if (![12, 15, 18, 21, 24].includes(word_count)) {
                    result += "<span class='warn'>Warning: Word count should be 12, 15, 18, 21, or 24</span>\n";
                }
                
                result += "\n<span class='" + (is_valid ? "success" : "error") + "'>BIP39 Valid: " + (is_valid ? "‚úì Yes" : "‚úó No") + "</span>";
                
                if (is_valid) {
                    result += "\n\n<span class='info'>Entropy bits:</span> " + (word_count / 3 * 32);
                    result += "\n<span class='info'>Checksum bits:</span> " + (word_count / 3);
                }
                
                output.innerHTML = result;
            } catch (e) {
                logError("validateMnemonic", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function useTestPhrase() {
            document.getElementById("validate-input").value = TestVector.test_phrase;
            validateMnemonic();
        }

        function mnemonicToSeed() {
            const output = document.getElementById("seed-output"),
                  mnemonic = document.getElementById("seed-mnemonic").value.trim(),
                  passphrase = document.getElementById("seed-passphrase").value;
            
            if (!mnemonic) {
                output.innerHTML = "<span class='warn'>Please enter a mnemonic phrase</span>";
                return;
            }
            
            try {
                if (!Bip39Utils.validate_mnemonic(mnemonic)) {
                    output.innerHTML = "<span class='error'>Invalid mnemonic phrase</span>";
                    return;
                }
                
                const seed = Bip39Utils.mnemonic_to_seed(mnemonic, passphrase);
                
                let result = "<span class='info'>Mnemonic:</span>\n" + mnemonic + "\n\n";
                if (passphrase) {
                    result += "<span class='info'>Passphrase:</span> \"" + passphrase + "\"\n\n";
                }
                result += "<span class='info'>512-bit Seed (hex):</span>\n" + seed + "\n\n";
                result += "<span class='info'>Seed length:</span> " + seed.length + " hex chars (" + (seed.length * 4) + " bits)";
                
                output.innerHTML = result;
            } catch (e) {
                logError("mnemonicToSeed", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function useTestPhraseForSeed() {
            document.getElementById("seed-mnemonic").value = TestVector.test_phrase;
            mnemonicToSeed();
        }

        function seedToRootKey() {
            const output = document.getElementById("rootkey-output"),
                  seed = document.getElementById("rootkey-seed").value.trim();
            
            if (!seed) {
                output.innerHTML = "<span class='warn'>Please enter a seed</span>";
                return;
            }
            
            if (seed.length !== 128 || !/^[0-9a-fA-F]+$/.test(seed)) {
                output.innerHTML = "<span class='error'>Seed must be 128 hex characters</span>";
                return;
            }
            
            try {
                const root_key = Bip39Utils.get_rootkey(seed),
                      master_key = root_key.slice(0, 64),
                      chain_code = root_key.slice(64);
                
                let result = "<span class='info'>Master Root Key (HMAC-SHA512 with \"Bitcoin seed\"):</span>\n\n";
                result += "<span class='info'>Master Private Key:</span>\n" + master_key + "\n\n";
                result += "<span class='info'>Master Chain Code:</span>\n" + chain_code;
                
                output.innerHTML = result;
            } catch (e) {
                logError("seedToRootKey", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function useTestSeed() {
            document.getElementById("rootkey-seed").value = TestVector.expected_seed;
            seedToRootKey();
        }

        function deriveKey() {
            const output = document.getElementById("derive-output"),
                  key = document.getElementById("derive-key").value.trim(),
                  chaincode = document.getElementById("derive-chaincode").value.trim(),
                  pathBase = document.getElementById("derive-path-base").value,
                  pathIndex = document.getElementById("derive-path-index").value,
                  path = pathBase + pathIndex,
                  coinValue = document.getElementById("derive-coin").value;
            
            if (!key || !chaincode) {
                output.innerHTML = "<span class='warn'>Please enter master key and chain code</span>";
                return;
            }
            
            try {
                // Handle segwit variants - use base coin config
                const isSegwit = coinValue.endsWith("-segwit"),
                      baseCoin = isSegwit ? coinValue.replace("-segwit", "") : coinValue,
                      derived = Bip39Utils.derive_x({
                        dpath: path,
                        key: key,
                        cc: chaincode
                      }),
                      pubkey = CryptoUtils.get_publickey(derived.key);
                
                // Get config - use Kaspa fallback if needed
                let config = Bip39Utils.get_bip32_config(baseCoin);
                if (!config && baseCoin === "kaspa") {
                    config = KASPA_CONFIG;
                }
                
                // Generate address based on coin type
                let address;
                if (isSegwit && baseCoin === "bitcoin") {
                    address = CryptoUtils.pub_to_address_bech32("bc", pubkey);
                } else if (isSegwit && baseCoin === "litecoin") {
                    address = CryptoUtils.pub_to_address_bech32("ltc", pubkey);
                } else if (baseCoin === "kaspa") {
                    address = CryptoUtils.pub_to_kaspa_address(pubkey);
                } else {
                    const formatted = Bip39Utils.format_keys(null, derived, config, 0, baseCoin);
                    address = formatted.address;
                }
                
                const coinLabel = document.getElementById("derive-coin").selectedOptions[0].text;
                
                let result = "<span class='info'>Derivation Path:</span> <span class='derivation-path'>" + path + "</span>\n";
                result += "<span class='info'>Coin:</span> " + coinLabel + "\n\n";
                result += "<span class='info'>Derived Public Key:</span>\n" + pubkey + "\n\n";
                result += "<span class='info'>Address:</span>\n<span class='success'>" + address + "</span>\n\n";
                result += "<span class='info'>Chain Code:</span>\n" + derived.chaincode + "\n\n";
                result += "<span class='info'>Fingerprint:</span> " + derived.fingerprint;
                
                output.innerHTML = result;
            } catch (e) {
                logError("deriveKey", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function updateDerivePath() {
            const select = document.getElementById("derive-coin"),
                  pathBaseInput = document.getElementById("derive-path-base"),
                  keyInput = document.getElementById("derive-key"),
                  chaincodeInput = document.getElementById("derive-chaincode"),
                  selectedOption = select.selectedOptions[0],
                  newPath = selectedOption.getAttribute("data-path");
            if (newPath) {
                pathBaseInput.value = newPath;
                // Auto-derive if key and chaincode are already filled in
                if (keyInput.value.trim() && chaincodeInput.value.trim()) {
                    deriveKey();
                }
            }
        }

        function deriveKeyIfReady() {
            const keyInput = document.getElementById("derive-key"),
                  chaincodeInput = document.getElementById("derive-chaincode");
            if (keyInput.value.trim() && chaincodeInput.value.trim()) {
                deriveKey();
            }
        }

        function useTestRootKey() {
            const seed = TestVector.expected_seed,
                  root_key = Bip39Utils.get_rootkey(seed);
            document.getElementById("derive-key").value = root_key.slice(0, 64);
            document.getElementById("derive-chaincode").value = root_key.slice(64);
            deriveKey();
        }

        function batchDerive() {
            const output = document.getElementById("batch-output"),
                  mnemonic = document.getElementById("batch-mnemonic").value.trim(),
                  coinValue = document.getElementById("batch-coin").value,
                  count = parseInt(document.getElementById("batch-count").value) || 5;
            
            if (!mnemonic) {
                output.innerHTML = "<span class='warn'>Please enter a mnemonic phrase</span>";
                return;
            }
            
            if (!Bip39Utils.validate_mnemonic(mnemonic)) {
                output.innerHTML = "<span class='error'>Invalid mnemonic phrase</span>";
                return;
            }
            
            try {
                const isSegwit = coinValue.endsWith("-segwit"),
                      baseCoin = isSegwit ? coinValue.replace("-segwit", "") : coinValue,
                      seed = Bip39Utils.mnemonic_to_seed(mnemonic),
                      root_key = Bip39Utils.get_rootkey(seed),
                      master_key = root_key.slice(0, 64),
                      chain_code = root_key.slice(64);
                
                // Get config - use Kaspa fallback if needed
                let config = Bip39Utils.get_bip32_config(baseCoin);
                if (!config && baseCoin === "kaspa") {
                    config = KASPA_CONFIG;
                }
                
                // Determine the correct path based on segwit vs legacy
                let root_path;
                if (isSegwit && baseCoin === "bitcoin") {
                    root_path = "m/84'/0'/0'/0/";
                } else if (isSegwit && baseCoin === "litecoin") {
                    root_path = "m/84'/2'/0'/0/";
                } else if (baseCoin === "bitcoin") {
                    root_path = "m/44'/0'/0'/0/";
                } else if (baseCoin === "litecoin") {
                    root_path = "m/44'/2'/0'/0/";
                } else if (baseCoin === "kaspa") {
                    root_path = "m/44'/111111'/0'/0/";
                } else {
                    root_path = config.root_path;
                }
                
                const coinLabel = document.getElementById("batch-coin").selectedOptions[0].text;
                
                let result = "<span class='info'>Coin:</span> " + coinLabel + "\n";
                result += "<span class='info'>Path:</span> <span class='derivation-path'>" + root_path + "[0-" + (count - 1) + "]</span>\n\n";
                result += "<span class='info'>Derived Addresses:</span>\n\n";
                
                for (let i = 0; i < count; i++) {
                    const path = root_path + i,
                          derived = Bip39Utils.derive_x({
                              dpath: path,
                              key: master_key,
                              cc: chain_code
                          }),
                          pubkey = CryptoUtils.get_publickey(derived.key);
                    
                    let address;
                    if (isSegwit && baseCoin === "bitcoin") {
                        address = CryptoUtils.pub_to_address_bech32("bc", pubkey);
                    } else if (isSegwit && baseCoin === "litecoin") {
                        address = CryptoUtils.pub_to_address_bech32("ltc", pubkey);
                    } else if (baseCoin === "kaspa") {
                        address = CryptoUtils.pub_to_kaspa_address(pubkey);
                    } else {
                        const formatted = Bip39Utils.format_keys(seed, derived, config, i, baseCoin);
                        address = formatted.address;
                    }
                    
                    result += "<span class='info'>[" + i + "]</span> " + address + "\n";
                }
                
                output.innerHTML = result;
            } catch (e) {
                logError("batchDerive", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function useTestPhraseForBatch() {
            document.getElementById("batch-mnemonic").value = TestVector.test_phrase;
            batchDerive();
        }

        function generateAllXpubs() {
            const output = document.getElementById("xpub-gen-output"),
                  mnemonic = document.getElementById("xpub-gen-mnemonic").value.trim();
            
            if (!mnemonic) {
                output.innerHTML = "<span class='warn'>Please enter a mnemonic phrase</span>";
                return;
            }
            
            if (!Bip39Utils.validate_mnemonic(mnemonic)) {
                output.innerHTML = "<span class='error'>Invalid mnemonic phrase</span>";
                return;
            }
            
            try {
                const seed = Bip39Utils.mnemonic_to_seed(mnemonic),
                      root_key = Bip39Utils.get_rootkey(seed),
                      master_key = root_key.slice(0, 64),
                      chain_code = root_key.slice(64),
                      // Define all coin configs with their xpub paths
                      xpub_configs = [
                        { name: "BTC SegWit", path: "m/84'/0'/0'", coin: "bitcoin", use_zpub: true },
                        { name: "BTC Legacy", path: "m/44'/0'/0'", coin: "bitcoin", use_zpub: false },
                        { name: "LTC SegWit", path: "m/84'/2'/0'", coin: "litecoin", use_zpub: true },
                        { name: "LTC Legacy", path: "m/44'/2'/0'", coin: "litecoin", use_zpub: false },
                        { name: "DOGE", path: "m/44'/3'/0'", coin: "dogecoin", use_zpub: false },
                        { name: "DASH", path: "m/44'/5'/0'", coin: "dash", use_zpub: false, use_bitcoin_prefix: true },
                        { name: "BCH", path: "m/44'/145'/0'", coin: "bitcoin-cash", use_zpub: false },
                        { name: "ETH", path: "m/44'/60'/0'", coin: "ethereum", use_zpub: false },
                        { name: "KAS (kpub)", path: "m/44'/111111'/0'", coin: "kaspa", use_zpub: false, use_kaspa: true }
                      ];
                
                let result = "<span class='info'>Extended Public Keys:</span>\n\n";
                
                for (const cfg of xpub_configs) {
                    // Derive to account level
                    const derived = Bip39Utils.derive_x({
                        dpath: cfg.path,
                        key: master_key,
                        cc: chain_code
                    });
                    
                    // Get config and potentially override for zpub/xpub
                    let coin_config = Bip39Utils.get_bip32_config(cfg.coin);
                    
                    // For Kaspa, use KASPA_CONFIG
                    if (cfg.use_kaspa) {
                        coin_config = KASPA_CONFIG;
                    }
                    // For DASH, use Bitcoin xpub prefix to match common wallet formats
                    else if (cfg.use_bitcoin_prefix) {
                        coin_config = {
                            ...coin_config,
                            prefix: {
                                ...coin_config.prefix,
                                pubx: 76067358 // Bitcoin xpub version
                            }
                        };
                    }
                    
                    // ext_keys with derived (which has xpub: false from "m/..." path) returns both xprv and xpub
                    const ext_keys_result = Bip39Utils.ext_keys(derived, coin_config),
                          xpub = ext_keys_result.xpub;
                    
                    result += "<span class='info'>" + cfg.name + ":</span>\n";
                    result += "<span class='derivation-path'>" + cfg.path + "</span>\n";
                    result += xpub + "\n\n";
                }
                
                output.innerHTML = result;
            } catch (e) {
                logError("generateAllXpubs", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        function useTestPhraseForXpubs() {
            document.getElementById("xpub-gen-mnemonic").value = TestVector.test_phrase;
            generateAllXpubs();
        }

        function parseXpub() {
            const output = document.getElementById("xpub-output"),
                  xpub = document.getElementById("xpub-input").value.trim();
            
            if (!xpub) {
                output.innerHTML = "<span class='warn'>Please enter an xpub</span>";
                return;
            }
            
            try {
                const parsed = Bip39Utils.key_cc_xpub(xpub),
                      extended = Bip39Utils.objectify_extended(CryptoUtils.b58check_decode(xpub)),
                      // Version byte mapping to coin type
                      version_map = {
                        "0488b21e": { name: "xpub (BTC/BCH/ETH)", coins: ["btc-legacy", "bch", "eth"] },
                        "04b24746": { name: "zpub (BTC/LTC SegWit)", coins: ["btc-segwit", "ltc-segwit"] },
                        "019da462": { name: "Ltub (LTC Legacy)", coins: ["ltc-legacy"] },
                        "02facafd": { name: "dgub (DOGE)", coins: ["doge"] },
                        "02fe52cc": { name: "drkp (DASH)", coins: ["dash"] },
                        "038f332e": { name: "kpub (Kaspa)", coins: ["kaspa"] }
                      },
                      version_info = version_map[extended.version] || { name: "Unknown", coins: [] };
                
                let result = "<span class='info'>Extended Public Key:</span>\n" + xpub + "\n\n";
                result += "<span class='info'>Version:</span> " + extended.version + " (" + version_info.name + ")\n";
                result += "<span class='info'>Depth:</span> " + parseInt(extended.depth, 16) + "\n";
                result += "<span class='info'>Fingerprint:</span> " + extended.fingerprint + "\n";
                result += "<span class='info'>Child Number:</span> " + extended.childnumber + "\n\n";
                result += "<span class='info'>Chain Code:</span>\n" + parsed.cc + "\n\n";
                result += "<span class='info'>Public Key:</span>\n" + parsed.key + "\n\n";
                
                // Get selected index
                const addr_index = parseInt(document.getElementById("xpub-index").value) || 0;
                
                // Derive address at selected index (M/0/index) from xpub
                result += "<span class='info'>Derived Addresses (index " + addr_index + "):</span>\n\n";
                
                // Derive M/0/index - public key derivation
                const derived = Bip39Utils.derive_x({
                    dpath: "M/0/" + addr_index,
                    key: parsed.key,
                    cc: parsed.cc
                }),
                child_pub_key = derived.key;
                
                // Generate addresses for different formats based on version
                if (extended.version === "04b24746") {
                    // zpub - SegWit
                    const btc_segwit = CryptoUtils.pub_to_address_bech32("bc", child_pub_key),
                          ltc_segwit = CryptoUtils.pub_to_address_bech32("ltc", child_pub_key);
                    result += "<span class='info'>BTC SegWit:</span> " + btc_segwit + "\n";
                    result += "<span class='info'>LTC SegWit:</span> " + ltc_segwit + "\n";
                } else if (extended.version === "0488b21e") {
                    // xpub - Could be BTC Legacy, LTC Legacy, BCH, ETH, DASH, or DOGE
                    const btc_legacy = CryptoUtils.pub_to_address("00", child_pub_key),
                          ltc_legacy = CryptoUtils.pub_to_address("30", child_pub_key),
                          bch_addr = CryptoUtils.pub_to_cashaddr(btc_legacy),
                          dash_addr = CryptoUtils.pub_to_address("4c", child_pub_key),
                          doge_addr = CryptoUtils.pub_to_address("1e", child_pub_key),
                          eth_pub_expanded = CryptoUtils.expand_pub(child_pub_key),
                          eth_addr = CryptoUtils.to_checksum_address(CryptoUtils.pub_to_eth_address(eth_pub_expanded));
                    result += "<span class='info'>BTC Legacy:</span> " + btc_legacy + "\n";
                    result += "<span class='info'>LTC Legacy:</span> " + ltc_legacy + "\n";
                    result += "<span class='info'>BCH:</span> " + bch_addr + "\n";
                    result += "<span class='info'>DASH:</span> " + dash_addr + "\n";
                    result += "<span class='info'>DOGE:</span> " + doge_addr + "\n";
                    result += "<span class='info'>ETH:</span> " + eth_addr + "\n";
                } else if (extended.version === "019da462") {
                    // Ltub - Litecoin Legacy
                    const ltc_legacy = CryptoUtils.pub_to_address("30", child_pub_key);
                    result += "<span class='info'>LTC Legacy:</span> " + ltc_legacy + "\n";
                } else if (extended.version === "02facafd") {
                    // dgub - Dogecoin
                    const doge_addr = CryptoUtils.pub_to_address("1e", child_pub_key);
                    result += "<span class='info'>DOGE:</span> " + doge_addr + "\n";
                } else if (extended.version === "02fe52cc" || extended.version === "02fe524c") {
                    // drkp - Dash
                    const dash_addr = CryptoUtils.pub_to_address("4c", child_pub_key);
                    result += "<span class='info'>DASH:</span> " + dash_addr + "\n";
                } else if (extended.version === "038f332e") {
                    // kpub - Kaspa
                    const kaspa_addr = CryptoUtils.pub_to_kaspa_address(child_pub_key);
                    result += "<span class='info'>KAS:</span> " + kaspa_addr + "\n";
                } else {
                    // Unknown - try common formats
                    const legacy_addr = CryptoUtils.pub_to_address("00", child_pub_key);
                    result += "<span class='info'>Legacy (0x00):</span> " + legacy_addr + "\n";
                }
                
                output.innerHTML = result;
            } catch (e) {
                logError("parseXpub", e);
                output.innerHTML = "<span class='error'>Error: " + (e.message || e) + "</span>";
            }
        }

        // Run tests on load
        window.onload = function() {
            runAllTests();
        };
    </script>
</body>
</html>